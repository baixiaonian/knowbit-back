# 文档向量更新策略

## 🎯 问题

用户编辑文档时，前端每秒都会发起保存请求。
如何智能地更新向量，平衡成本、性能和实时性？

---

## 💡 推荐方案：多层策略

### 策略1：防抖机制（Debounce）⭐ 推荐

**原理**：只在用户停止编辑一段时间后才向量化

```
用户编辑: t0 → t1 → t2 → t3 → t4 → (停止) → t4+3分钟
保存请求: ✓    ✓    ✓    ✓    ✓              触发向量化 ✅

好处：
✅ 避免频繁调用API
✅ 降低成本（只在真正完成编辑后处理）
✅ 用户无感知（后台异步）
```

**实现**：

1. 文档每次保存时：
   ```python
   # 只更新documents表
   document.content = new_content
   document.updated_at = now()
   
   # 标记需要重新向量化（不立即执行）
   if content_changed:
       document.vectorization_status = 'pending'
   ```

2. 后台定时任务（每分钟运行）：
   ```python
   # 查找：状态=pending 且 3分钟内无更新的文档
   docs = SELECT * FROM documents
          WHERE vectorization_status = 'pending'
          AND updated_at < (now() - interval '3 minutes')
   
   # 异步向量化这些文档
   for doc in docs:
       vectorize_in_background(doc)
   ```

### 策略2：内容哈希检测

**原理**：只在内容真正改变时才重新向量化

```python
# 计算内容哈希
old_hash = MD5(old_content)
new_hash = MD5(new_content)

if old_hash != new_hash:
    # 内容真正改变了
    mark_for_vectorization()
else:
    # 只是标题、标签等元数据改变，不需要重新向量化
    skip_vectorization()
```

**好处**：
- ✅ 避免不必要的向量化
- ✅ 节省成本
- ✅ 提高效率

### 策略3：智能队列优先级

**优先级排序**：
```sql
SELECT * FROM documents
WHERE vectorization_status = 'pending'
ORDER BY
    CASE 
        WHEN is_public = true THEN 1  -- 公开文档优先
        ELSE 2
    END,
    updated_at DESC                   -- 最近更新的优先
LIMIT 10
```

---

## 🏗️ 完整架构

```
┌─────────────────────────────────────────────┐
│           前端编辑器                         │
│  用户编辑 → 每秒自动保存                     │
└─────────────┬───────────────────────────────┘
              │
              ▼
┌─────────────────────────────────────────────┐
│     文档保存API (快速响应)                   │
│  1. 更新documents表                          │
│  2. 检查内容是否改变 (hash对比)               │
│  3. 如果改变 → 标记status='pending'           │
│  4. 返回成功                                 │
└─────────────┬───────────────────────────────┘
              │
              ▼
┌─────────────────────────────────────────────┐
│     防抖机制                                 │
│  等待3分钟无更新                             │
└─────────────┬───────────────────────────────┘
              │
              ▼
┌─────────────────────────────────────────────┐
│     后台Worker (每分钟运行)                  │
│  1. 查询pending文档                          │
│  2. 过滤：updated_at < now()-3分钟            │
│  3. 异步向量化                               │
│  4. 更新status='completed'                   │
└─────────────────────────────────────────────┘
```

---

## 💻 代码实现

### 1. 修改Document模型

```python
# app/models/document.py
class Document(Base):
    # ... 现有字段
    
    # 新增字段
    vectorized_at = Column(TIMESTAMP(timezone=True))
    vectorization_status = Column(String(20), default='pending')
    content_hash = Column(String(64))
```

### 2. 修改文档保存API

```python
# app/api/documents.py

from app.services.vectorization_task import VectorizationTaskService

@router.put("/documents/{document_id}")
async def update_document(...):
    # 原有的更新逻辑
    ...
    
    # 新增：智能向量化标记
    if doc_data.content is not None:
        task_service = VectorizationTaskService(db)
        
        # 检查内容是否真正改变
        content_changed = await task_service.check_if_content_changed(
            document_id, 
            doc_data.content
        )
        
        if content_changed:
            # 标记需要重新向量化
            await task_service.mark_document_for_vectorization(
                document_id,
                doc_data.content
            )
    
    # 快速返回，不等待向量化
    return success_response
```

### 3. 启动后台Worker

```python
# main.py

from app.services.vectorization_task import run_vectorization_worker
import asyncio

@app.on_event("startup")
async def startup_event():
    """应用启动时启动后台任务"""
    # 在后台运行向量化worker
    asyncio.create_task(run_vectorization_worker())
```

---

## 📊 不同方案对比

### 方案A：实时向量化（不推荐）

```
每次保存 → 立即向量化

优点：
✅ 向量始终最新

缺点：
❌ API调用频繁（每秒1次）
❌ 成本极高（100倍）
❌ 响应慢（等待1-2秒）
❌ 用户体验差
```

### 方案B：手动触发（简单但不智能）

```
用户点击"向量化"按钮 → 向量化

优点：
✅ 完全可控
✅ 成本低

缺点：
❌ 用户容易忘记
❌ 搜索结果可能过时
❌ 额外操作步骤
```

### 方案C：防抖 + 后台队列（推荐）⭐

```
保存 → 标记 → 3分钟后 → 后台处理

优点：
✅ 自动化，用户无感知
✅ 成本可控（编辑完成后才处理）
✅ 不影响保存速度
✅ 向量相对实时

缺点：
⚠️ 有3分钟延迟（可接受）
```

### 方案D：混合策略（高级）

```
- 自动保存 → 标记pending（防抖3分钟）
- 发布文档 → 立即向量化
- 手动触发 → 立即向量化
```

---

## ⚙️ 参数配置

### 防抖时间设置

```python
# 开发环境：快速测试
DEBOUNCE_TIME = 60  # 1分钟

# 生产环境：平衡体验
DEBOUNCE_TIME = 180  # 3分钟

# 高频编辑场景
DEBOUNCE_TIME = 300  # 5分钟
```

### Worker执行频率

```python
# 检查间隔
CHECK_INTERVAL = 60  # 每分钟检查一次

# 批量大小
BATCH_SIZE = 10  # 每次处理10个文档
```

---

## 🎯 优化建议

### 优化1：智能检测内容变化

```python
# 不仅检查哈希，还检查变化程度
def should_revectorize(old_content, new_content):
    # 1. 哈希对比
    if hash(old_content) == hash(new_content):
        return False
    
    # 2. 变化幅度对比
    diff_ratio = len_diff(old_content, new_content) / len(old_content)
    
    if diff_ratio < 0.05:  # 变化小于5%
        return False  # 不需要重新向量化
    
    return True
```

### 优化2：增量向量化（高级）

```python
# 只向量化改变的部分
# 保留未改变chunks的向量

old_chunks = get_existing_chunks()
new_chunks = split_text(new_content)

# 对比找出变化的chunks
changed_chunks = diff(old_chunks, new_chunks)

# 只向量化变化的部分
vectorize_only(changed_chunks)
```

### 优化3：用户状态感知

```python
# 检测用户是否在编辑
if user_is_editing:
    # 延长防抖时间
    debounce_time = 300
else:
    # 缩短防抖时间
    debounce_time = 60
```

---

## 📈 成本对比

### 假设：100个用户，每人每天编辑10篇文档

#### 方案A：实时向量化
```
编辑时长：平均5分钟 = 300次保存请求
向量化次数：100用户 × 10文档 × 300次 = 300,000次/天

Embedding成本：
300,000次 × 2000 tokens × $0.00002/1K = $12/天 = $360/月

结论：成本太高 ❌
```

#### 方案C：防抖（3分钟）
```
向量化次数：100用户 × 10文档 × 1次 = 1,000次/天

Embedding成本：
1,000次 × 2000 tokens × $0.00002/1K = $0.04/天 = $1.2/月

节省：99.7%！✅
```

---

## 🚀 快速实施步骤

### 步骤1：执行数据库脚本
```bash
psql -U your_user -d your_db -f update_documents_table.sql
```

### 步骤2：修改文档保存API
在 `app/api/documents.py` 的 `update_document` 和 `autosave_document` 中添加：

```python
# 导入
from app.services.vectorization_task import VectorizationTaskService
import hashlib

# 在保存content时添加
if doc_data.content is not None:
    # 计算内容哈希
    new_hash = hashlib.md5(doc_data.content.encode()).hexdigest()
    
    # 检查是否改变
    if document.content_hash != new_hash:
        document.content_hash = new_hash
        document.vectorization_status = 'pending'
        # 不立即向量化，只标记
```

### 步骤3：启动后台Worker
在 `main.py` 添加：

```python
from app.services.vectorization_task import run_vectorization_worker
import asyncio

@app.on_event("startup")
async def startup_event():
    asyncio.create_task(run_vectorization_worker())
```

### 步骤4：（可选）提供手动触发接口
```python
@router.post("/documents/{id}/vectorize-now")
async def force_vectorize(document_id: int):
    """立即向量化（不等待防抖）"""
    # 立即执行向量化
```

---

## 🎓 最佳实践

### 1. 分场景处理

```python
# 自动保存（频繁）→ 标记pending，3分钟防抖
@router.post("/documents/{id}/autosave")

# 发布文档（重要）→ 立即向量化
@router.post("/documents/{id}/publish")
async def publish():
    vectorize_immediately()

# 手动触发 → 立即向量化  
@router.post("/documents/{id}/vectorize")
```

### 2. 状态管理

```python
状态流转：
pending → processing → completed
   ↓          ↓            ↓
 等待      执行中      已完成
   ↓                      
failed (如果失败)

查询：
- 显示向量化状态给用户
- 搜索时过滤未向量化的文档
```

### 3. 错误处理

```python
# 失败重试机制
if status == 'failed':
    retry_count += 1
    if retry_count < 3:
        status = 'pending'  # 重新尝试
```

---

## 📋 总结

### 推荐配置

```python
# 配置参数
DEBOUNCE_TIME = 180          # 3分钟防抖
WORKER_INTERVAL = 60         # 每分钟检查一次
BATCH_SIZE = 10             # 每次处理10个
CONTENT_CHANGE_THRESHOLD = 0.05  # 内容变化>5%才重新向量化
```

### 实施优先级

**MVP阶段（必须）**：
- [x] 添加vectorization_status字段
- [x] 保存时标记pending
- [ ] 后台Worker定时处理

**进阶优化（可选）**：
- [ ] 内容哈希检测
- [ ] 手动触发按钮
- [ ] 向量化进度显示
- [ ] 增量向量化

### 成本效益

```
实时向量化：  $360/月
防抖策略：     $1.2/月

节省：99.7% 💰
```

**推荐：防抖策略（方案C）** - 成本低、体验好、实现简单！

